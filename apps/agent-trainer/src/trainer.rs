use anyhow::{Result, Context};
use shared::types::{ActionType, Agent, AgentType, LearnedTask};
use uuid::Uuid;

/// Generates a runnable Rust agent from a `LearnedTask`.
pub fn train_agent_from_task(task: &LearnedTask) -> Result<Agent> {
    let _rust_code = generate_rust_code(task)
        .context("Failed to generate Rust code for the agent")?;

    let agent = Agent {
        id: Uuid::new_v4(),
        name: format!("Agent for '{}'", task.name),
        description: task.description.clone(),
        agent_type: AgentType::Rust,
        executable_path: std::path::PathBuf::new(), // This will be set after compilation
    };

    // For now, we're not compiling, just returning the agent struct.
    // The `persistence` module will save the generated code.
    Ok(agent)
}

/// Generates the full Rust source code for a `thirtyfour` automation script.
pub fn generate_rust_code(task: &LearnedTask) -> Result<String> {
    let mut code = String::new();

    // --- Add Header and Imports ---
    code.push_str(&format!(
        r#"
// Generated by Agent-Trainer
// This is a self-contained Rust script that uses thirtyfour to automate a browser.

use thirtyfour::{{prelude::*, support::sleep}};
use std::time::Duration;
use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {{
    let caps = DesiredCapabilities::chrome();
    let driver = WebDriver::new("http://localhost:9515", caps).await?;

    println!("Agent starting automation for task: {}");

"#,
        task.name
    ));

    // --- Generate Code for Each Step ---
    for step in &task.steps {
        let step_code = match &step.action_type {
            ActionType::Navigate => {
                let url = step.data.as_deref().unwrap_or_default();
                format!("    println!(\"Navigating to {}\");\n    driver.goto(\"{}\").await?;\n", url, url)
            }
            ActionType::Click => {
                let selector = step.target.as_ref().map_or("", |t| &t.value);
                format!(
                    "    println!(\"Clicking on element with selector: {}\");\n    driver.find(By::Css(\"{}\")).await?.click().await?;\n",
                    selector, selector
                )
            }
            ActionType::Type => {
                let selector = step.target.as_ref().map_or("", |t| &t.value);
                let text_to_type = step.data.as_deref().unwrap_or_default();
                let escaped_text = text_to_type.replace('"', "\\\"");
                format!(
                    "    println!(\"Typing into element with selector: {}\");\n    driver.find(By::Css(\"{}\")).await?.send_keys(\"{}\").await?;\n",
                    selector, selector, escaped_text
                )
            }
            ActionType::Wait => {
                let ms = step.data.as_deref().unwrap_or("1000").parse::<u64>().unwrap_or(1000);
                format!("    println!(\"Waiting for {}ms\");\n    sleep(Duration::from_millis({})).await;\n", ms, ms)
            }
            ActionType::Scroll => {
                 // This is a placeholder, as we don't have coordinates in the new structure.
                 format!("    println!(\"Scrolling (placeholder)\");\n")
            }
            _ => format!("    // Action type {:?} not yet implemented.\n", step.action_type),
        };
        code.push_str(&step_code);
    }

    // --- Add Footer ---
    code.push_str(
        r#"
    println!("Automation task finished successfully.");
    driver.quit().await?;
    Ok(())
}
"#,
    );

    Ok(code)
}
